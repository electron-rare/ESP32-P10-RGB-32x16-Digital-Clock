//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// ##################################################################################
// # I SUGGEST YOU WATCH THE VIDEO UNTIL THE END, SO YOU KNOW HOW TO USE THIS CODE. #
// ##################################################################################
//
// Information about the P10 RGB Panel that I use :
// - P10 RGB 32x16 HUB75 Scan 1/8 Full Color SMD.
// - Information written on the P10 RGB board : P10-2727-8S-32X16-A
// - IC or Chip on the P10 RGB board :
//   > RUC7258D
//   > DP5125D
//   > 74HC245KA
// - HUB75 (Scan 1/8) : 
//    -----------
//   | DR1 | DG1 |
//   | DB1 | GND |
//   | DR2 | DG2 |
//   | DB2 | GND |
//   |  A  |  B  |
//   |  C  | GND |
//   | CLK | STB |
//   | OE  | GND |
//    -----------
// 
// Software :
// - Arduino IDE 1.8.19
// 
// Arduino core for the ESP32 :
// - Arduino core for the ESP32, ESP32-S2, ESP32-S3, ESP32-C3, ESP32-C6 and ESP32-H2 (V2.0.16).
// 
// Arduino Libraries :
// - Adafruit BusIO by Adafruit (V1.16.1).
// - Adafruit GFX Library by Adafruit (V1.11.9).
// - PxMatrix Library by 2dom (Dominic Buchstaller) (V1.8.2).
// - RTClib by Adafruit (V2.1.4)
// 
// Hardware :
// - ESP32 DEVKIT V1.
// - P10 RGB 32x16.
// - DS3231 RTC Module.
// - 5V Power Supply.
// - For more details, see the installation picture.
// 
// Troubleshooting : https://github.com/2dom/PxMatrix/tree/master?tab=readme-ov-file#troubleshooting
//
// Reference :
// - PxMatrix : https://github.com/2dom/PxMatrix/tree/master
// - Power, Power and Power! : https://github.com/mrcodetastic/ESP32-HUB75-MatrixPanel-DMA?tab=readme-ov-file#power-power-and-power
// - Micro Controller | ESP LED Matrix P10 RGB : https://andriantriputra.medium.com/micro-controller-esp-led-matrix-p10-rgb-fcb21b576296
// - Adafruit_GFX getTextBounds() : https://forums.adafruit.com/viewtopic.php?p=486141#p486141
// - Adafruit GFX font size points to pixels for Epapers : https://forum.arduino.cc/t/adafruit-gfx-font-size-points-to-pixels-for-epapers/556091/11
// - localIP2st : https://gist.github.com/loosak/76019faaefd5409fca67
// - ESP32 Save Data Permanently using Preferences Library : https://randomnerdtutorials.com/esp32-save-data-permanently-preferences/
// - And from other sources.
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 01_Test_and_Setup_DS3231_RTC_Module
//----------------------------------------Including Libraries.
#include "RTClib.h"
//----------------------------------------

char daysOfTheWeek[8][10] = {"SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "ERROR"};

String inputString = "";  // a String to hold incoming data.
bool stringComplete = false;  // whether the string is complete.

int d_year;
byte d_month, d_day, daysOfTheWeek_Val;
byte t_hour, t_minute, t_second;

unsigned long prevMill_Update_DateTime = 0;
const long interval_Update_DateTime = 1000;

RTC_DS3231 rtc;






//________________________________________________________________________________ VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  delay(2000);
  Serial.begin(115200);

  // reserve 200 bytes for the inputString.
  inputString.reserve(200);

  //----------------------------------------Starting and setting up the DS3231 RTC module.
  Serial.println();
  Serial.println("------------");
  Serial.println("Starting the DS3231 RTC module.");
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    while (1);
  }
  Serial.println("Successfully started the DS3231 RTC module.");
  Serial.println("------------");
  Serial.println();
  //----------------------------------------
  
  //----------------------------------------
  Serial.println();
  Serial.println("------------");
  Serial.println("Serial monitor settings :");
  Serial.println("- End Char  : Newline");
  Serial.println("- Baud Rate : 115200");
  Serial.println("------------");
  Serial.println();
  //----------------------------------------

  Serial.println();
  Serial.println("------------");
  Serial.println("Example command to set the time and date on the RTC module : ");
  Serial.println("SET,2024,7,9,12,3,0");
  Serial.println();
  Serial.println("SET = command to set.");
  Serial.println("2024 = Year.");
  Serial.println("7 = Month.");
  Serial.println("9=Day.");
  Serial.println("12 = Hour.");
  Serial.println("3 = Minute.");
  Serial.println("0 = Second.");
  Serial.println("------------");
  Serial.println();

  delay(3000);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  serialEvent();

  unsigned long currentMillis_Update_DateTime = millis();
  if (currentMillis_Update_DateTime - prevMill_Update_DateTime >= interval_Update_DateTime) {
    prevMill_Update_DateTime = currentMillis_Update_DateTime;

    get_DateTime();
  }

  // print the string when a newline arrives.
  if (stringComplete) {
    Serial.print("Input String : ");
    Serial.println(inputString);

    String command = "";
    command = getValue(inputString, ',', 0);

    if (command == "SET") {
      Serial.println();
      Serial.println("------------");
      Serial.println("Set the Time and Date of the DS3231 RTC Module.");
      Serial.println("Incoming settings data : ");
      
      d_year = getValue(inputString, ',', 1).toInt();
      d_month = getValue(inputString, ',', 2).toInt();
      d_day = getValue(inputString, ',', 3).toInt();
      t_hour = getValue(inputString, ',', 4).toInt();
      t_minute = getValue(inputString, ',',5).toInt();
      t_second = getValue(inputString, ',', 6).toInt();

      Serial.print("- Year : ");Serial.println(d_year);
      Serial.print("- Month : ");Serial.println(d_month);
      Serial.print("- Day : ");Serial.println(d_day);
      Serial.print("- Hour : ");Serial.println(t_hour);
      Serial.print("- Minute : ");Serial.println(t_minute);
      Serial.print("- Second : ");Serial.println(t_second);
      
      Serial.println("Set Time and Date...");
      rtc.adjust(DateTime(d_year, d_month, d_day, t_hour, t_minute, t_second));

      Serial.println("Setting the Time and Date has been completed.");
      Serial.println("------------");
      Serial.println();
    }
    
    // clear the string:
    inputString = "";
    stringComplete = false;
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ serialEvent()
void serialEvent() {
  while (Serial.available()) {
    // get the new byte.
    char inChar = (char)Serial.read();

    // if the incoming character is a newline, set a flag so the main loop can do something about it.
    if (inChar == '\n') {
      stringComplete = true;
      return;
    }
    
    // add it to the inputString.
    inputString += inChar;
  }
}
//________________________________________________________________________________ 

//________________________________________________________________________________ getValue()
// String function to process the data received
// I got this from : https://www.electroniclinic.com/reyax-lora-based-multiple-sensors-monitoring-using-arduino/
String getValue(String data, char separator, int index) {
  int found = 0;
  int strIndex[] = { 0, -1 };
  int maxIndex = data.length() - 1;
  
  for (int i = 0; i <= maxIndex && found <= index; i++) {
    if (data.charAt(i) == separator || i == maxIndex) {
      found++;
      strIndex[0] = strIndex[1] + 1;
      strIndex[1] = (i == maxIndex) ? i+1 : i;
    }
  }
  return found > index ? data.substring(strIndex[0], strIndex[1]) : "";
}
//________________________________________________________________________________ 






//________________________________________________________________________________ get_DateTime()
void get_DateTime() {
  DateTime now = rtc.now();

  d_year = now.year();
  d_month = now.month();
  d_day = now.day();
  daysOfTheWeek_Val = now.dayOfTheWeek();
  if (daysOfTheWeek_Val > 7 || daysOfTheWeek_Val < 0) daysOfTheWeek_Val = 7;
  t_hour = now.hour();
  t_minute = now.minute();
  t_second = now.second();

  char full_DateTime[60];
  sprintf(full_DateTime, "%s | %02d-%02d-%d | %02d:%02d:%02d", daysOfTheWeek[daysOfTheWeek_Val], d_day, d_month, d_year, t_hour, t_minute, t_second);

  Serial.print("Date Time : ");
  Serial.println(full_DateTime);
}
//________________________________________________________________________________ 
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 02_Test_P10_RGB_32x16
// This is how many color levels the display shows - the more the slower the update.
//#define PxMATRIX_COLOR_DEPTH 4

// Defines the speed of the SPI bus (reducing this may help if you experience noisy images).
// The original value of PxMATRIX_SPI_FREQUENCY in the PxMatrix library example is 20000000.
// I changed the value to 10000000 because if I use the value 20000000, then "ghosting" or "noise" appears on my P10 32x16 RGB panel.
// Each panel may be a different case. If "ghosting" or "noise" appears on your P10 RGB panel, try changing the PxMATRIX_SPI_FREQUENCY value.
// You can use the values ​​20000000, 15000000, 10000000 and 8000000. Or you can also try using other values.
#define PxMATRIX_SPI_FREQUENCY 10000000

// Creates a second buffer for backround drawing (doubles the required RAM).
//#define PxMATRIX_double_buffer true

//----------------------------------------Including Libraries.
#include <PxMatrix.h>
//----------------------------------------

//----------------------------------------Pins for LED MATRIX.
#define P_LAT 5
#define P_A   19
#define P_B   23
#define P_C   18
#define P_OE  4
//----------------------------------------

// Defines the width and height of the panel in pixels.
#define matrix_width  32
#define matrix_height 16

// Timer setup.
// Create a hardware timer  of ESP32.
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// This defines the 'on' time of the display is us.
// The larger this number, the brighter the display. If too large the ESP will crash.
uint8_t display_draw_time = 30; // 30-70 is usually fine.

// Declaring the "PxMATRIX" object as a "display" and its settings.
PxMATRIX display(matrix_width, matrix_height, P_LAT, P_OE, P_A, P_B, P_C);

//----------------------------------------Variable for some colors.
// display.color565(R value = 0-255, G value = 0-255, B value = 0-255);
uint16_t myRED      = display.color565(255, 0, 0);
uint16_t myGREEN    = display.color565(0, 255, 0);
uint16_t myBLUE     = display.color565(0, 0, 255);
uint16_t myYELLOW   = display.color565(255, 255, 0);
uint16_t myCYAN     = display.color565(0, 255, 255);
uint16_t myFUCHSIA  = display.color565(255, 0, 255);
uint16_t myBLACK    = display.color565(0, 0, 0);
uint16_t myWHITE    = display.color565(255, 255, 255);

uint16_t myCOLOR_ARRAY[4] = {myRED, myGREEN, myBLUE, myWHITE};
//----------------------------------------






//________________________________________________________________________________ IRAM_ATTR display_updater()
// Interrupt handler for Timer.
void IRAM_ATTR display_updater(){
  // Increment the counter and set the time of ISR.
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(display_draw_time);
  portEXIT_CRITICAL_ISR(&timerMux);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ display_update_enable()
// Subroutine to enable and disable interrupt timers.
void display_update_enable(bool is_enable) {
  if (is_enable){
    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &display_updater, true);
    timerAlarmWrite(timer, 1500, true);
    timerAlarmEnable(timer);
  }
  else{
    timerDetachInterrupt(timer);
    timerAlarmDisable(timer);
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  delay(2000);
  Serial.begin(115200);
  Serial.println();

  // Display initialization.
  display.begin(8); //--> Value 8 for 1/8 row scan panel.
  delay(100);

  // Enable Timer Interrupts.
  display_update_enable(true);
  delay(100);

  display.clearDisplay();
  delay(1000);

  display.setBrightness(125); //--> Range from 0 to 255.
  delay(100);

  display.fillScreen(myRED);
  delay(1000);
  display.fillScreen(myGREEN);
  delay(1000);
  display.fillScreen(myBLUE);
  delay(1000);
  display.fillScreen(myWHITE);
  delay(1000);

  display.clearDisplay();
  delay(1000);

  display.setTextWrap(false);
  display.setTextSize(1);
  display.setRotation(0);
  delay(100);

  display.fillScreen(display.color565(255, 0, 0));
  display.setTextColor(display.color565(255, 255, 255));
  display.setCursor(0, 0);
  display.print("UTEH");
  display.setTextColor(display.color565(255, 255, 255));
  display.setCursor(15, 9);
  display.print("STR");
  delay(2500);

  display.clearDisplay();
  delay(1000);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  int myCOLOR_ARRAY_Length = sizeof(myCOLOR_ARRAY) / sizeof(myCOLOR_ARRAY[0]);
  
  for (byte i = 0; i < myCOLOR_ARRAY_Length; i++) {
    display.setTextColor(myCOLOR_ARRAY[i]);
    display.setCursor(0, 0);
    display.print("1234");
    display.setCursor(0, 9);
    display.print("ABCD");
    delay(2500);

    display.clearDisplay();
    delay(1000);

    display.setTextColor(myCOLOR_ARRAY[i]);
    display.setCursor(4, 0);
    display.print("1234");
    display.setCursor(4, 9);
    display.print("ABCD");
    delay(2500);

    display.clearDisplay();
    delay(1000);

    display.setCursor(9, 0);
    display.print("1234");
    display.setCursor(9, 9);
    display.print("ABCD");
    delay(2500);
  
    display.clearDisplay();
    delay(1000);
  }
}
//________________________________________________________________________________ 
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 03_P10_RGB_32x16_Digital_Clock
// This is how many color levels the display shows - the more the slower the update.
//#define PxMATRIX_COLOR_DEPTH 4

// Defines the speed of the SPI bus (reducing this may help if you experience noisy images).
// The original value of PxMATRIX_SPI_FREQUENCY in the PxMatrix library example is 20000000.
// I changed the value to 10000000 because if I use the value 20000000, then "ghosting" or "noise" appears on my P10 32x16 RGB panel.
// Each panel may be a different case. If "ghosting" or "noise" appears on your P10 RGB panel, try changing the PxMATRIX_SPI_FREQUENCY value.
// You can use the values ​​20000000, 15000000, 10000000 and 8000000. Or you can also try using other values.
#define PxMATRIX_SPI_FREQUENCY 10000000

// Creates a second buffer for backround drawing (doubles the required RAM).
//#define PxMATRIX_double_buffer true

//----------------------------------------Including Libraries.
#include <PxMatrix.h>
#include "RTClib.h"
//----------------------------------------

//----------------------------------------Pins for LED MATRIX.
#define P_LAT 5
#define P_A   19
#define P_B   23
#define P_C   18
#define P_OE  4
//----------------------------------------

// Defines the width and height of the panel in pixels.
#define matrix_width  32
#define matrix_height 16

// Timer setup.
// Create a hardware timer  of ESP32.
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// This defines the 'on' time of the display is us.
// The larger this number, the brighter the display. If too large the ESP will crash.
uint8_t display_draw_time = 30; // 30-70 is usually fine.

// Declaring the "PxMATRIX" object as a "display" and its settings.
PxMATRIX display(matrix_width, matrix_height, P_LAT, P_OE, P_A, P_B, P_C);

//----------------------------------------Variable for some colors.
uint16_t myRED      = display.color565(255, 0, 0);
uint16_t myGREEN    = display.color565(0, 255, 0);
uint16_t myBLUE     = display.color565(0, 0, 255);
uint16_t myYELLOW   = display.color565(255, 255, 0);
uint16_t myCYAN     = display.color565(0, 255, 255);
uint16_t myFUCHSIA  = display.color565(255, 0, 255);
uint16_t myWHITE    = display.color565(255, 255, 255);
uint16_t myBLACK    = display.color565(0, 0, 0);

uint16_t myCOLOR_ARRAY[7] = {myRED, myGREEN, myBLUE, myYELLOW, myCYAN, myFUCHSIA, myWHITE};
int cnt_Color = 0;
int myCOLOR_ARRAY_Length = sizeof(myCOLOR_ARRAY) / sizeof(myCOLOR_ARRAY[0]);
//----------------------------------------

// Timer/millis variables for scrolling text.
unsigned long prevMill_Scroll_Text = 0;
byte scrolling_Speed = 35;

// Variables used to scroll text.
int scrolling_Y_Pos = 0;
long scrolling_X_Pos;
long scrolling_X_Pos_CT;
uint16_t scrolling_Text_Color;
uint16_t text_Color;
char scrolling_Text[151];
uint16_t text_Length_In_Pixel;
bool set_up_Scrolling_Text_Length = true;
bool start_Scroll_Text = false;
byte scrolling_text_Display_Order = 0;
byte Display_Mode;

// Timer/millis variable to update time data.
unsigned long prevMill_Update_Time = 0;
const long interval_Update_Time = 1000;

// Timer/millis variable to display time (hours and minutes).
unsigned long prevMill_Show_Clock = 0;
const long interval_Show_Clock = 500;

// Variables to hold date and time data.
char daysOfTheWeek[7][10] = {"SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"};
char t_Minute[3];
byte minute_Val, last_minute_Val;
char t_Hour[3];
char day_and_date_Text[25];
bool blink_Colon = false;
uint16_t clock_Color;
uint16_t day_and_date_Text_Color;

// Declare the “RTC_DS3231” object as “rtc”.
RTC_DS3231 rtc;






//________________________________________________________________________________ IRAM_ATTR display_updater()
// Interrupt handler for Timer.
void IRAM_ATTR display_updater(){
  // Increment the counter and set the time of ISR.
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(display_draw_time);
  portEXIT_CRITICAL_ISR(&timerMux);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ display_update_enable()
// Subroutine to enable and disable interrupt timers.
void display_update_enable(bool is_enable) {
  if (is_enable){
    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &display_updater, true);
    timerAlarmWrite(timer, 1500, true);
    timerAlarmEnable(timer);
  }
  else{
    timerDetachInterrupt(timer);
    timerAlarmDisable(timer);
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ run_Scrolling_Text()
// Subroutine for scrolling text.
void run_Scrolling_Text(uint8_t st_Y_Pos, byte st_Speed, char * st_Text, uint16_t st_Color) {
  if (start_Scroll_Text == true && set_up_Scrolling_Text_Length == true) {
    if (strlen(st_Text) > 0) {
      text_Length_In_Pixel = getTextWidth(st_Text);
      scrolling_X_Pos = matrix_width;
      
      set_up_Scrolling_Text_Length = false;
    } else {
      start_Scroll_Text = false;
      return;
    }
  }

  unsigned long currentMillis_Scroll_Text = millis();
  if (currentMillis_Scroll_Text - prevMill_Scroll_Text >= st_Speed) {
    prevMill_Scroll_Text = currentMillis_Scroll_Text;

    scrolling_X_Pos--;
    if (scrolling_X_Pos < -(matrix_width + text_Length_In_Pixel)) {
      set_up_Scrolling_Text_Length = true;
      start_Scroll_Text = false;
      
      return;
    }

    scrolling_X_Pos_CT = scrolling_X_Pos + 1;
    
    display.setTextColor(myBLACK);
    display.setCursor(scrolling_X_Pos_CT, st_Y_Pos);
    display.print(st_Text);
    
    display.setTextColor(st_Color);
    display.setCursor(scrolling_X_Pos, st_Y_Pos);
    display.print(st_Text);
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ getTextWidth()
// Subroutine to get the length of text in pixels.
uint16_t getTextWidth(const char* text) {
  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(text, 0, 0, &x1, &y1, &w, &h);
  return w;
}
//________________________________________________________________________________ 






//________________________________________________________________________________ drawColon()
void drawColon(int16_t x, int16_t y, uint16_t colonColor) {
  display.drawPixel(x, y, colonColor);
  display.drawPixel(x+1, y, colonColor);
  display.drawPixel(x, y+1, colonColor);
  display.drawPixel(x+1, y+1, colonColor);

  display.drawPixel(x, y+3, colonColor);
  display.drawPixel(x+1, y+3, colonColor);
  display.drawPixel(x, y+4, colonColor);
  display.drawPixel(x+1, y+4, colonColor);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ get_Time()
void get_Time() {
  DateTime now = rtc.now();

  minute_Val = now.minute();
  
  sprintf(t_Hour, "%02d", now.hour());
  sprintf(t_Minute, "%02d", now.minute());
}
//________________________________________________________________________________ 






//________________________________________________________________________________ get_Date()
void get_Date() {
  DateTime now = rtc.now();

  sprintf(day_and_date_Text, "%s, %02d-%02d-%d", daysOfTheWeek[now.dayOfTheWeek()], now.day(), now.month(), now.year());
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  delay(1000);
  Serial.begin(115200);
  Serial.println();

  //----------------------------------------Starting and setting up the DS3231 RTC module.
  Serial.println();
  Serial.println("------------");
  Serial.println("Starting the DS3231 RTC module.");
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    while (1);
  }
  Serial.println("Successfully started the DS3231 RTC module.");
  Serial.println("------------");
  //----------------------------------------

  // Display initialization.
  display.begin(8); //--> Value 8 for 1/8 row scan panel.
  delay(100);

  // Enable Timer Interrupts.
  display_update_enable(true);
  delay(100);

  display.clearDisplay();
  delay(1000);

  display.setBrightness(125); //--> Range from 0 to 255.
  delay(100);

  display.fillScreen(myRED);
  delay(1000);
  display.fillScreen(myGREEN);
  delay(1000);
  display.fillScreen(myBLUE);
  delay(1000);
  display.fillScreen(myWHITE);
  delay(1000);

  display.clearDisplay();
  delay(1000);

  display.setTextWrap(false);
  display.setTextSize(1);
  display.setRotation(0);
  delay(1000);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  //----------------------------------------Set the Clock and Date display mode.
  // - Display_Mode = 1. The colors for the clock display, scrolling text for the date and other scrolling text are set manually.
  // - Display_Mode = 2. The colors for the clock display, scrolling text for the date and other scrolling text change sequentially based on the color list above.
  Display_Mode = 1;
  //----------------------------------------




  //----------------------------------------Display_Mode = 1.
  if (Display_Mode == 1) {
    //::::::::::::::::::Timer/Millis to update clock data.
    unsigned long currentMillis_Update_Time = millis();
    if (currentMillis_Update_Time - prevMill_Update_Time >= interval_Update_Time) {
      prevMill_Update_Time = currentMillis_Update_Time;

      get_Time();
      blink_Colon = !blink_Colon;
    }
    //::::::::::::::::::

    //::::::::::::::::::Timer/Millis to display hours and minutes.
    unsigned long currentMillis_Show_Clock = millis();
    if (currentMillis_Show_Clock - prevMill_Show_Clock >= interval_Show_Clock) {
      prevMill_Show_Clock = currentMillis_Show_Clock;

      display.setTextSize(1);

      clock_Color = myRED;

      if (last_minute_Val != minute_Val) display.fillRect(1, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(1, 0);
      display.print(t_Hour);

      if (blink_Colon == true) {
        drawColon(15, 1, clock_Color);
      } else {
        drawColon(15, 1, myBLACK);
      }

      if (last_minute_Val != minute_Val) display.fillRect(20, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(20, 0);
      display.print(t_Minute);

      last_minute_Val = minute_Val;
    }
    //::::::::::::::::::

    //::::::::::::::::::Conditions for setting and preparing scrolling text.
    // "start_Scroll_Text = false" means scrolling has not been executed.
    // After the settings and preparations for scrolling text below are complete, "start_Scroll_Text = true" to start scrolling text.
    // "start_Scroll_Text" will return "false" if scrolling the text is complete or the scrolled text is empty.
    if (start_Scroll_Text == false) {
      scrolling_text_Display_Order++;
      if (scrolling_text_Display_Order > 2) scrolling_text_Display_Order = 1;

      // Conditions for scrolling text containing the name of the day and date.
      if (scrolling_text_Display_Order == 1) {
        get_Date();
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.
        day_and_date_Text_Color = myGREEN;
        scrolling_Text_Color = day_and_date_Text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(scrolling_Text, day_and_date_Text);  //--> Sets the displayed text on scrolling text.
      }

      // Conditions for scrolling the text you want.
      if (scrolling_text_Display_Order == 2) {
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.
        text_Color = myBLUE;
        scrolling_Text_Color = text_Color;  //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(scrolling_Text, "P10 RGB 32x16 Digital Clock. Display Mode : 1.");  //--> Sets the displayed text on scrolling text.
      }
      
      start_Scroll_Text = true;
    }
    //::::::::::::::::::
  }
  //----------------------------------------
  



  //----------------------------------------Display_Mode = 2.
  if (Display_Mode == 2) {
    //::::::::::::::::::
    unsigned long currentMillis_Update_Time = millis();
    if (currentMillis_Update_Time - prevMill_Update_Time >= interval_Update_Time) {
      prevMill_Update_Time = currentMillis_Update_Time;

      get_Time();
      blink_Colon = !blink_Colon;
    }
    //::::::::::::::::::

    //::::::::::::::::::
    unsigned long currentMillis_Show_Clock = millis();
    if (currentMillis_Show_Clock - prevMill_Show_Clock >= interval_Show_Clock) {
      prevMill_Show_Clock = currentMillis_Show_Clock;

      display.setTextSize(1);

      clock_Color = myCOLOR_ARRAY[cnt_Color];

      if (last_minute_Val != minute_Val) display.fillRect(1, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(1, 0);
      display.print(t_Hour);

      if (blink_Colon == true) {
        drawColon(15, 1, clock_Color);
      } else {
        drawColon(15, 1, myBLACK);
      }

      if (last_minute_Val != minute_Val) display.fillRect(20, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(20, 0);
      display.print(t_Minute);

      last_minute_Val = minute_Val;
    }
    //::::::::::::::::::

    //::::::::::::::::::
    if (start_Scroll_Text == false) {
      scrolling_text_Display_Order++;
      if (scrolling_text_Display_Order > 3) scrolling_text_Display_Order = 1;

      if (scrolling_text_Display_Order == 1) {
        get_Date();
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.

        int next_cnt_Color = cnt_Color + 1;
        if (next_cnt_Color > (myCOLOR_ARRAY_Length - 1)) next_cnt_Color = cnt_Color - (myCOLOR_ARRAY_Length - 1);
        day_and_date_Text_Color = myCOLOR_ARRAY[next_cnt_Color];
      
        scrolling_Text_Color = day_and_date_Text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(scrolling_Text, day_and_date_Text);  //--> Sets the displayed text on scrolling text.
      }

      if (scrolling_text_Display_Order == 2) {
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.

        int next_cnt_Color = cnt_Color + 2;
        if (next_cnt_Color > (myCOLOR_ARRAY_Length - 1)) next_cnt_Color = cnt_Color - (myCOLOR_ARRAY_Length - 2);
        text_Color = myCOLOR_ARRAY[next_cnt_Color];
        
        scrolling_Text_Color = text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);      
        strcpy(scrolling_Text, "P10 RGB 32x16 Digital Clock. Display Mode : 2.");  //--> Sets the displayed text on scrolling text.
      }

      // Conditions for changing color.
      if (scrolling_text_Display_Order == 3) {
        cnt_Color++;
        if (cnt_Color > (myCOLOR_ARRAY_Length - 1)) cnt_Color = 0;

        strcpy(scrolling_Text, "");
      }

      start_Scroll_Text = true;
    }
    //::::::::::::::::::
  }
  //----------------------------------------
  


  
  if (start_Scroll_Text == true) {
    run_Scrolling_Text(scrolling_Y_Pos, scrolling_Speed, scrolling_Text, scrolling_Text_Color);
  }
}
//________________________________________________________________________________ 
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 04_Erase_and_Reformat_The_NVS_Memory
#include <nvs_flash.h>

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  Serial.println();
  delay(1000);

  Serial.println("erase the NVS partition.");
  nvs_flash_erase();  // erase the NVS partition and...
  Serial.println("initialize the NVS partition.");
  nvs_flash_init();   // initialize the NVS partition.
  Serial.println("Finished.");
}

void loop() {
  // put your main code here, to run repeatedly:
  delay(10);
}
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 05_P10_RGB_32x16_Digital_Clock_Web_Server_SM
// This is how many color levels the display shows - the more the slower the update.
//#define PxMATRIX_COLOR_DEPTH 4

// Defines the speed of the SPI bus (reducing this may help if you experience noisy images).
#define PxMATRIX_SPI_FREQUENCY 10000000

// Creates a second buffer for backround drawing (doubles the required RAM).
//#define PxMATRIX_double_buffer true

//----------------------------------------Including Libraries.
#include <PxMatrix.h>
#include "RTClib.h"
#include <Preferences.h>
#include <WiFi.h>
#include <WebServer.h>
#include "PageIndex.h"
//----------------------------------------

//----------------------------------------Pins for LED MATRIX.
#define P_LAT 5
#define P_A   19
#define P_B   23
#define P_C   18
#define P_OE  4
//----------------------------------------

// Defines the width and height of the panel in pixels.
#define matrix_width  32
#define matrix_height 16

// Timer setup.
// Create a hardware timer  of ESP32.
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// This defines the 'on' time of the display is us.
// The larger this number, the brighter the display. If too large the ESP will crash.
uint8_t display_draw_time = 30; // 30-70 is usually fine.

// Declaring the "PxMATRIX" object as a "display" and its settings.
PxMATRIX display(matrix_width, matrix_height, P_LAT, P_OE, P_A, P_B, P_C);

//----------------------------------------Variable for some colors.
uint16_t myRED      = display.color565(255, 0, 0);
uint16_t myGREEN    = display.color565(0, 255, 0);
uint16_t myBLUE     = display.color565(0, 0, 255);
uint16_t myYELLOW   = display.color565(255, 255, 0);
uint16_t myCYAN     = display.color565(0, 255, 255);
uint16_t myFUCHSIA  = display.color565(255, 0, 255);
uint16_t myWHITE    = display.color565(255, 255, 255);
uint16_t myBLACK    = display.color565(0, 0, 0);

uint16_t myCOLOR_ARRAY[7] = {myRED, myGREEN, myBLUE, myYELLOW, myCYAN, myFUCHSIA, myWHITE};
int cnt_Color = 0;
int myCOLOR_ARRAY_Length = sizeof(myCOLOR_ARRAY) / sizeof(myCOLOR_ARRAY[0]);
//----------------------------------------

// Timer/millis variables for scrolling text.
unsigned long prevMill_Scroll_Text = 0;

// Variables used to scroll text.
int scrolling_Y_Pos = 0;
long scrolling_X_Pos;
long scrolling_X_Pos_CT;
uint16_t scrolling_Text_Color;
uint16_t text_Color;
char text_Scrolling_Text[151];
uint16_t text_Length_In_Pixel;
bool set_up_Scrolling_Text_Length = true;
bool start_Scroll_Text = false;
byte scrolling_text_Display_Order = 0;
bool reset_Scrolling_Text = false;

// Timer/millis variable to update time data.
unsigned long prevMill_Update_Time = 0;
const long interval_Update_Time = 1000;

// Timer/millis variable to display time (hours and minutes).
unsigned long prevMill_Show_Clock = 0;
const long interval_Show_Clock = 500;

// Variables to hold date and time data.
char daysOfTheWeek[7][10] = {"SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"};
char chr_t_Minute[3];
byte minute_Val, last_minute_Val;
char chr_t_Hour[3];
char day_and_date_Text[25];
bool blink_Colon = false;
uint16_t clock_Color;
uint16_t day_and_date_Text_Color;

int d_Year;
byte d_Month, d_Day;
byte t_Hour, t_Minute, t_Second;
byte input_Display_Mode, input_Brightness, input_Scrolling_Speed;
int Color_Clock_R, Color_Clock_G, Color_Clock_B;
int Color_Date_R, Color_Date_G, Color_Date_B;
int Color_Text_R, Color_Text_G, Color_Text_B;
char input_Scrolling_Text[151];

//----------------------------------------Variable declaration for your network credentials.
const char* ssid = "YOUR_WIFI_SSID";  //--> Your wifi name.
const char* password = "YOUR_WIFI_PASSWORD"; //--> Your wifi password.
//----------------------------------------

//----------------------------------------Defining the key.
// The "key" works like a password. To control the "P10 RGB 32x16", users must know the “key”.
// You can change it to another word.
#define key_Txt "p10rgbesp32ws"
//----------------------------------------

// Declare the “RTC_DS3231” object as “rtc”.
RTC_DS3231 rtc;

// Declaring the "Preferences" object as "preferences".
Preferences preferences;

// Server on port 80.
WebServer server(80);






//________________________________________________________________________________ IRAM_ATTR display_updater()
// Interrupt handler for Timer.
void IRAM_ATTR display_updater(){
  // Increment the counter and set the time of ISR.
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(display_draw_time);
  portEXIT_CRITICAL_ISR(&timerMux);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ display_update_enable()
// Subroutine to enable and disable interrupt timers.
void display_update_enable(bool is_enable) {
  if (is_enable){
    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &display_updater, true);
    timerAlarmWrite(timer, 1500, true);
    timerAlarmEnable(timer);
  }
  else{
    timerDetachInterrupt(timer);
    timerAlarmDisable(timer);
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ connecting_To_WiFi()
void connecting_To_WiFi() {
  //----------------------------------------Set Wifi to STA mode.
  Serial.println();
  Serial.println("-------------WIFI mode");
  Serial.println("WIFI mode : STA");
  WiFi.mode(WIFI_STA);
  Serial.println("-------------");
  delay(1000);
  //---------------------------------------- 

  //----------------------------------------Connect to Wi-Fi (STA).
  Serial.println();
  Serial.println("-------------Connection");
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  
  //:::::::::::::::::: The process of connecting ESP32 with WiFi Hotspot / WiFi Router.
  // The process timeout of connecting ESP32 with WiFi Hotspot / WiFi Router is 20 seconds.
  // If within 20 seconds the ESP32 has not been successfully connected to WiFi, the ESP32 will restart.
  // I made this condition because on my ESP32, there are times when it seems like it can't connect to WiFi, so it needs to be restarted to be able to connect to WiFi.
  
  int connecting_process_timed_out = 20; //--> 20 = 20 seconds.
  connecting_process_timed_out = connecting_process_timed_out * 2;
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
    if(connecting_process_timed_out > 0) connecting_process_timed_out--;
    if(connecting_process_timed_out == 0) {
      Serial.println();
      Serial.println("Failed to connect to WiFi. The ESP32 will be restarted.");
      Serial.println("-------------");
      delay(1000);
      ESP.restart();
    }
  }
  
  Serial.println();
  Serial.println("WiFi connected");
  Serial.print("Successfully connected to : ");
  Serial.println(ssid);
  Serial.println("-------------");
  //:::::::::::::::::: 
  delay(1000);
  //---------------------------------------- 
}
//________________________________________________________________________________ 






//________________________________________________________________________________ prepare_and_start_The_Server()
void prepare_and_start_The_Server() {
  //----------------------------------------Setting the server.
  server.on("/", handleRoot); 
  server.on("/settings", handleSettings);
  delay(500);
  //----------------------------------------

  //----------------------------------------Start server.
  server.begin(); 
  Serial.println();
  Serial.println("HTTP server started");
  delay(500);
  //----------------------------------------

  //----------------------------------------Open the IP address in your browser to open the interface page.
  // Make sure that your computer / mobile device and ESP32 are connected to the same WiFi network.
  Serial.println();
  Serial.print("IP address : ");
  Serial.println(WiFi.localIP());
  Serial.println("Open the IP address in your browser to open the interface page.");
  Serial.println("Make sure that your computer / mobile device and");
  Serial.println("ESP32 are connected to the same WiFi network.");
  delay(500);
  //----------------------------------------
}
//________________________________________________________________________________ 






//________________________________________________________________________________ handleRoot()
// This routine is executed when you open ESP32 IP Address in browser.
void handleRoot() {
  server.send(200, "text/html", MAIN_page); //--> Send web page.
}
//________________________________________________________________________________






//________________________________________________________________________________ handleSettings().
// Subroutines for handling handle settings from clients.
void handleSettings() {
  String incoming_Settings;
  
  incoming_Settings = server.arg("key");
  
  Serial.println();
  Serial.println("-------------Settings");
  Serial.print("Key : ");
  Serial.println(incoming_Settings);

  // Conditions for checking keys.
  if (incoming_Settings == key_Txt) {
    incoming_Settings = server.arg("sta");

    // Conditions for setting the Clock and Date.
    if (incoming_Settings == "setTimeDate") {
      incoming_Settings = server.arg("d_Year");
      d_Year = incoming_Settings.toInt();
      incoming_Settings = server.arg("d_Month");
      d_Month = incoming_Settings.toInt();
      incoming_Settings = server.arg("d_Day");
      d_Day = incoming_Settings.toInt();
      incoming_Settings = server.arg("t_Hour");
      t_Hour = incoming_Settings.toInt();
      incoming_Settings = server.arg("t_Minute");
      t_Minute = incoming_Settings.toInt();
      incoming_Settings = server.arg("t_Second");
      t_Second = incoming_Settings.toInt();

      char TD[40];
      sprintf(TD, "Date : %d-%d-%d | Time : %d-%d-%d", d_Day, d_Month, d_Year, t_Hour, t_Minute, t_Second);
      
      Serial.println();
      Serial.println("Set Time and Date.");
      Serial.print("DateTime : ");
      Serial.println(TD);

      Serial.println("Set Time and Date...");
      rtc.adjust(DateTime(d_Year, d_Month, d_Day, t_Hour, t_Minute, t_Second));
      delay(100);
      Serial.println("Setting the Time and Date has been completed.");
    }

    // Conditions for setting Display Mode.
    if (incoming_Settings == "setDisplayMode") {
      incoming_Settings = server.arg("input_Display_Mode");
      input_Display_Mode = incoming_Settings.toInt();
      
      Serial.println();
      Serial.println("Set Display Mode.");
      Serial.print("Display Mode : ");
      Serial.println(input_Display_Mode);

      Serial.println("Set and save Display Mode....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      // Save "input_Display_Mode" to flash memory with key name "input_DM".
      preferences.putInt("input_DM", input_Display_Mode);
      delay(100);

      // Gets the value of "input_Display_Mode" stored in flash memory.
      // If the key name "input_DM" is not found, then "input_Display_Mode" is 1 or "input_Display_Mode = 1".
      input_Display_Mode = preferences.getInt("input_DM", 1);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      if (input_Display_Mode == 1) {
        clock_Color = display.color565(Color_Clock_R, Color_Clock_G, Color_Clock_B);
        day_and_date_Text_Color = display.color565(Color_Date_R, Color_Date_G, Color_Date_B);
        text_Color = display.color565(Color_Text_R, Color_Text_G, Color_Text_B);
      }

      display.clearDisplay();

      reset_Scrolling_Text = true;

      // After the scrolling text display is reset, 
      // set "scrolling_text_Display_Order = 0" so that the scrolling text display starts from scrolling the name of the day and date.
      scrolling_text_Display_Order = 0;
      
      Serial.println("Set and save Display Mode is complete.");
    }

    // Conditions for setting Brightness.
    if (incoming_Settings == "setBrightness") {
      incoming_Settings = server.arg("input_Brightness");
      input_Brightness = incoming_Settings.toInt();

      if (input_Brightness > 255) input_Brightness = 255;
      if (input_Brightness < 0)   input_Brightness = 0;
      
      Serial.println();
      Serial.println("Set Brightness.");
      Serial.print("Brightness : ");
      Serial.println(input_Brightness);

      Serial.println("Set and save Brightness....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      // Save "input_Brightness" to flash memory with key name "input_BRT".
      preferences.putInt("input_BRT", input_Brightness);
      delay(100);

      // Gets the value of "input_Brightness" stored in flash memory.
      // If the key name "input_BRT" is not found, then "input_Brightness" is 125 or "input_Brightness = 125".
      input_Brightness = preferences.getInt("input_BRT", 125);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      display.setBrightness(input_Brightness);
      
      Serial.println("Set and save Brightness is complete.");
    }

    // Conditions for setting Clock Color.
    if (incoming_Settings == "setColorClock") {
      // Conditions for checking display mode.
      // Setting the clock color can only be done in display mode = 1.
      if (input_Display_Mode == 2) {
        server.send(200, "text/plane", "+ERR_DM"); //--> Sending replies to the client.
        delay(500);
        Serial.println("-------------");
        return;
      }
      
      incoming_Settings = server.arg("Color_Clock_R");
      Color_Clock_R = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Clock_G");
      Color_Clock_G = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Clock_B");
      Color_Clock_B = incoming_Settings.toInt();
      
      Serial.println();
      Serial.println("Set Clock Color.");
      Serial.print("Clock Color (RGB) : ");
      Serial.print(Color_Clock_R);Serial.print(",");Serial.print(Color_Clock_G);Serial.print(",");Serial.println(Color_Clock_B);

      Serial.println("Set and save Clock Color....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      // Saves "Color_Clock_R", "Color_Clock_G" and "Color_Clock_B" to flash memory with key names "CC_R", "CC_G" and "CC_B".
      preferences.putInt("CC_R", Color_Clock_R);
      delay(100);
      preferences.putInt("CC_G", Color_Clock_G);
      delay(100);
      preferences.putInt("CC_B", Color_Clock_B);
      delay(100);

      // Gets the values ​​of "Color_Clock_R", "Color_Clock_G" and "Color_Clock_B" stored in flash memory.
      // If the key names "Color_Clock_R", "Color_Clock_G" and "Color_Clock_B" are not found,
      // then "Color_Clock_R", "Color_Clock_G" and "Color_Clock_B" have a value of 255.
      Color_Clock_R = preferences.getInt("CC_R", 255);
      delay(100);
      Color_Clock_G = preferences.getInt("CC_G", 255);
      delay(100);
      Color_Clock_B = preferences.getInt("CC_B", 255);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      clock_Color = display.color565(Color_Clock_R, Color_Clock_G, Color_Clock_B);
      
      Serial.println("Set and save Clock Color is complete.");
    }

    // Conditions for setting Date Color.
    if (incoming_Settings == "setColorDate") {
      // Conditions for checking display mode.
      // Setting the date color can only be done in display mode = 1.
      if (input_Display_Mode == 2) {
        server.send(200, "text/plane", "+ERR_DM"); //--> Sending replies to the client.
        delay(500);
        Serial.println("-------------");
        return;
      }
      incoming_Settings = server.arg("Color_Date_R");
      Color_Date_R = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Date_G");
      Color_Date_G = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Date_B");
      Color_Date_B = incoming_Settings.toInt();
      
      Serial.println();
      Serial.println("Set Date Color.");
      Serial.print("Date Color (RGB) : ");
      Serial.print(Color_Date_R);Serial.print(",");Serial.print(Color_Date_G);Serial.print(",");Serial.println(Color_Date_B);

      Serial.println("Set and save Date Color....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      preferences.putInt("DC_R", Color_Date_R);
      delay(100);
      preferences.putInt("DC_G", Color_Date_G);
      delay(100);
      preferences.putInt("DC_B", Color_Date_B);
      delay(100);

      Color_Date_R = preferences.getInt("DC_R", 255);
      delay(100);
      Color_Date_G = preferences.getInt("DC_G", 255);
      delay(100);
      Color_Date_B = preferences.getInt("DC_B", 255);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      display.clearDisplay();
      
      reset_Scrolling_Text = true;

      // After the scrolling text display is reset, 
      // set "scrolling_text_Display_Order = 0" so that the scrolling text display starts from scrolling the name of the day and date.
      scrolling_text_Display_Order = 0;
      
      day_and_date_Text_Color = display.color565(Color_Date_R, Color_Date_G, Color_Date_B);
      
      Serial.println("Set and save Date Color is complete.");
    }

    // Conditions for setting text on Scrolling Text.
    if (incoming_Settings == "setScrollingText") {
      incoming_Settings = server.arg("input_Scrolling_Text");
      String my_Scrolling_Text = incoming_Settings;
      int my_Scrolling_Text_Length = my_Scrolling_Text.length() + 1;
      my_Scrolling_Text.toCharArray(input_Scrolling_Text, my_Scrolling_Text_Length);
      
      Serial.println();
      Serial.println("Set Scrolling Text.");
      Serial.print("Text : ");
      Serial.println(input_Scrolling_Text);

      Serial.println("Set and save Scrolling Text....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      preferences.putString("input_ST", input_Scrolling_Text);
      delay(100);

      my_Scrolling_Text = preferences.getString("input_ST", "");
      my_Scrolling_Text_Length = my_Scrolling_Text.length() + 1;
      my_Scrolling_Text.toCharArray(input_Scrolling_Text, my_Scrolling_Text_Length);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      display.clearDisplay();
      
      reset_Scrolling_Text = true;

      // Once the scrolling text display is reset,
      // set "scrolling_text_Display_Order = 1" so that the scrolling text display starts from scrolling "input_Scrolling_Text".
      scrolling_text_Display_Order = 1;
      
      Serial.println("Set and save Scrolling Text is complete.");
    }

    // Conditions for setting Text Color.
    if (incoming_Settings == "setTextColor") {
      // Conditions for checking display mode.
      // Setting the text color can only be done in display mode = 1.
      if (input_Display_Mode == 2) {
        server.send(200, "text/plane", "+ERR_DM"); //--> Sending replies to the client.
        delay(500);
        Serial.println("-------------");
        return;
      }
      
      incoming_Settings = server.arg("Color_Text_R");
      Color_Text_R = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Text_G");
      Color_Text_G = incoming_Settings.toInt();
      incoming_Settings = server.arg("Color_Text_B");
      Color_Text_B = incoming_Settings.toInt();
      
      Serial.println();
      Serial.println("Set Text Color.");
      Serial.print("Text Color (RGB) : ");
      Serial.print(Color_Text_R);Serial.print(",");Serial.print(Color_Text_G);Serial.print(",");Serial.println(Color_Text_B);

      Serial.println("Set and save Text Color....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      preferences.putInt("TC_R", Color_Text_R);
      delay(100);
      preferences.putInt("TC_G", Color_Text_G);
      delay(100);
      preferences.putInt("TC_B", Color_Text_B);
      delay(100);

      Color_Text_R = preferences.getInt("TC_R", 255);
      delay(100);
      Color_Text_G = preferences.getInt("TC_G", 255);
      delay(100);
      Color_Text_B = preferences.getInt("TC_B", 255);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000);

      display.clearDisplay();

      reset_Scrolling_Text = true;

      // Once the scrolling text display is reset,
      // set "scrolling_text_Display_Order = 1" so that the scrolling text display starts from scrolling "input_Scrolling_Text".
      scrolling_text_Display_Order = 1;

      text_Color = display.color565(Color_Text_R, Color_Text_G, Color_Text_B);
      
      Serial.println("Set and save Text Color is complete.");
    }

    // Conditions for setting Scrolling Speed.
    if (incoming_Settings == "setScrollingSpeed") {
      incoming_Settings = server.arg("input_Scrolling_Speed");
      input_Scrolling_Speed = incoming_Settings.toInt();
      
      Serial.println();
      Serial.println("Set Scrolling Speed.");
      Serial.print("Scrolling Speed : ");
      Serial.println(input_Scrolling_Speed);

      Serial.println("Set and save Scrolling Speed....");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      //::::::::::::::::::
      // Open Preferences.
      preferences.begin("mySettings", false);
      delay(500);

      preferences.putInt("input_SS", input_Scrolling_Speed);
      delay(100);

      input_Scrolling_Speed = preferences.getInt("input_SS", 35);
      delay(100);

      // Close the Preferences.
      preferences.end();
      delay(500);
      //::::::::::::::::::

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000); 
      
      Serial.println("Set and save Scrolling Speed is complete.");
    }

    // Sends settings stored in flash memory to the client.
    if (incoming_Settings == "getSettings") {
      Serial.println();
      Serial.println("Get Settings.");

      // Disable Timer Interrupts.
      display_update_enable(false);
      delay(1000);

      get_All_Saved_Settings();

      // Enable Timer Interrupts.
      display_update_enable(true);
      delay(1000); 
      
      char send_Settings[200];
      sprintf(send_Settings, "%d|%d|%d|%d|%d|%d|%d|%d|%s|%d|%d|%d|%d", input_Display_Mode, input_Brightness, 
                                                                       Color_Clock_R, Color_Clock_G, Color_Clock_B,
                                                                       Color_Date_R, Color_Date_G, Color_Date_B,
                                                                       input_Scrolling_Text,
                                                                       Color_Text_R, Color_Text_G, Color_Text_B,
                                                                       input_Scrolling_Speed);

      Serial.print("Settings Data :");
      Serial.println(send_Settings);

      server.send(200, "text/plane", send_Settings);  //--> Sending replies to the client.
      delay(500);
    }
    Serial.println("-------------");

    server.send(200, "text/plane", "+OK"); //--> Sending replies to the client.
    delay(500);
  } else {
    Serial.println();
    Serial.println("Wrong Key Text !");
    Serial.println("Please enter the correct Key Text.");
    Serial.println("-------------");
    
    server.send(200, "text/plane", "+ERR"); //--> Sending replies to the client.
    delay(500);
  }
}
//________________________________________________________________________________






//________________________________________________________________________________ get_All_Saved_Settings()
void get_All_Saved_Settings() {
  // Open Preferences.
  preferences.begin("mySettings", false);
  delay(500);

  input_Display_Mode = preferences.getInt("input_DM", 1);
  input_Brightness = preferences.getInt("input_BRT", 125);
  Color_Clock_R = preferences.getInt("CC_R", 255);
  Color_Clock_G = preferences.getInt("CC_G", 255);
  Color_Clock_B = preferences.getInt("CC_B", 255);
  clock_Color = display.color565(Color_Clock_R, Color_Clock_G, Color_Clock_B);
  Color_Date_R = preferences.getInt("DC_R", 255);
  Color_Date_G = preferences.getInt("DC_G", 255);
  Color_Date_B = preferences.getInt("DC_B", 255);
  day_and_date_Text_Color = display.color565(Color_Date_R, Color_Date_G, Color_Date_B);
  String my_Scrolling_Text = preferences.getString("input_ST", "");
  int my_Scrolling_Text_Length = my_Scrolling_Text.length() + 1;
  my_Scrolling_Text.toCharArray(input_Scrolling_Text, my_Scrolling_Text_Length);
  Color_Text_R = preferences.getInt("TC_R", 255);
  Color_Text_G = preferences.getInt("TC_G", 255);
  Color_Text_B = preferences.getInt("TC_B", 255);
  text_Color = display.color565(Color_Text_R, Color_Text_G, Color_Text_B);
  input_Scrolling_Speed = preferences.getInt("input_SS", 35);

  // Close the Preferences.
  preferences.end();
  delay(500);

  Serial.println("-------------");
  Serial.println("All Saved Settings.");
  Serial.print("Display Mode : ");
  Serial.println(input_Display_Mode);
  Serial.print("Brightness : ");
  Serial.println(input_Brightness);
  Serial.print("Clock Color (RGB) : ");
  Serial.print(Color_Clock_R);Serial.print(",");Serial.print(Color_Clock_G);Serial.print(",");Serial.println(Color_Clock_B);
  Serial.print("Date Color (RGB) : ");
  Serial.print(Color_Date_R);Serial.print(",");Serial.print(Color_Date_G);Serial.print(",");Serial.println(Color_Date_B);
  Serial.print("Scrolling Text : ");
  Serial.println(input_Scrolling_Text);
  Serial.print("Text Color (RGB) : ");
  Serial.print(Color_Text_R);Serial.print(",");Serial.print(Color_Text_G);Serial.print(",");Serial.println(Color_Text_B);
  Serial.print("Scrolling Speed : ");
  Serial.println(input_Scrolling_Speed);
  Serial.println("-------------");
}
//________________________________________________________________________________






//________________________________________________________________________________ run_Scrolling_Text()
// Subroutine for scrolling text.
void run_Scrolling_Text(uint8_t st_Y_Pos, byte st_Speed, char * st_Text, uint16_t st_Color) {
  if (start_Scroll_Text == true && set_up_Scrolling_Text_Length == true) {
    if (strlen(st_Text) > 0) {
      text_Length_In_Pixel = getTextWidth(st_Text);
      scrolling_X_Pos = matrix_width;
      
      set_up_Scrolling_Text_Length = false;
    } else {
      start_Scroll_Text = false;
      return;
    }
  }

  if (reset_Scrolling_Text == true) {
    set_up_Scrolling_Text_Length = true;
    start_Scroll_Text = false;
    reset_Scrolling_Text = false;
    
    return;
  }

  unsigned long currentMillis_Scroll_Text = millis();
  if (currentMillis_Scroll_Text - prevMill_Scroll_Text >= st_Speed) {
    prevMill_Scroll_Text = currentMillis_Scroll_Text;

    scrolling_X_Pos--;
    if (scrolling_X_Pos < -(matrix_width + text_Length_In_Pixel)) {
      set_up_Scrolling_Text_Length = true;
      start_Scroll_Text = false;
      
      return;
    }

    scrolling_X_Pos_CT = scrolling_X_Pos + 1;
    
    display.setTextColor(myBLACK);
    display.setCursor(scrolling_X_Pos_CT, st_Y_Pos);
    display.print(st_Text);
    
    display.setTextColor(st_Color);
    display.setCursor(scrolling_X_Pos, st_Y_Pos);
    display.print(st_Text);
  }
}
//________________________________________________________________________________ 






//________________________________________________________________________________ getTextWidth()
// Subroutine to get the length of text in pixels.
uint16_t getTextWidth(const char* text) {
  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(text, 0, 0, &x1, &y1, &w, &h);
  return w;
}
//________________________________________________________________________________ 






//________________________________________________________________________________ drawColon()
void drawColon(int16_t x, int16_t y, uint16_t colonColor) {
  display.drawPixel(x, y, colonColor);
  display.drawPixel(x+1, y, colonColor);
  display.drawPixel(x, y+1, colonColor);
  display.drawPixel(x+1, y+1, colonColor);

  display.drawPixel(x, y+3, colonColor);
  display.drawPixel(x+1, y+3, colonColor);
  display.drawPixel(x, y+4, colonColor);
  display.drawPixel(x+1, y+4, colonColor);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ get_Time()
void get_Time() {
  DateTime now = rtc.now();

  minute_Val = now.minute();
  
  sprintf(chr_t_Hour, "%02d", now.hour());
  sprintf(chr_t_Minute, "%02d", now.minute());
}
//________________________________________________________________________________ 






//________________________________________________________________________________ get_Date()
void get_Date() {
  DateTime now = rtc.now();

  sprintf(day_and_date_Text, "%s, %02d-%02d-%d", daysOfTheWeek[now.dayOfTheWeek()], now.day(), now.month(), now.year());
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID SETUP()
void setup() {
  // put your setup code here, to run once:

  delay(1000);
  Serial.begin(115200);
  Serial.println();

  get_All_Saved_Settings();

  //----------------------------------------Starting and setting up the DS3231 RTC module.
  Serial.println();
  Serial.println("------------");
  Serial.println("Starting the DS3231 RTC module.");
  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
    while (1);
  }
  Serial.println("Successfully started the DS3231 RTC module.");
  Serial.println("------------");
  //----------------------------------------

  // Display initialization.
  display.begin(8); //--> Value 8 for 1/8 row scan panel.
  delay(100);

  // Enable Timer Interrupts.
  display_update_enable(true);
  delay(100);

  display.clearDisplay();
  delay(1000);

  display.setBrightness(input_Brightness); //--> Range from 0 to 255.
  delay(100);

  display.fillScreen(myRED);
  delay(1000);
  display.fillScreen(myGREEN);
  delay(1000);
  display.fillScreen(myBLUE);
  delay(1000);
  display.fillScreen(myWHITE);
  delay(1000);

  display.clearDisplay();
  delay(1000);

  display.setTextWrap(false);
  display.setTextSize(1);
  display.setRotation(0);
  delay(100);

  start_Scroll_Text = true;
  while(true) {run_Scrolling_Text(4, 35, "Connecting to WiFi.", myBLUE);if (start_Scroll_Text == false) break;}
  delay(500);

  start_Scroll_Text = true;
  while(true) {run_Scrolling_Text(4, 35, "Please Wait...", myRED);if (start_Scroll_Text == false) break;}
  delay(500);

  // Disable Timer Interrupts.
  display_update_enable(false);
  delay(1000);

  connecting_To_WiFi();
  delay(1000);

  prepare_and_start_The_Server();
  delay(1000);

  // Enable Timer Interrupts.
  display_update_enable(true);
  delay(1000);

  start_Scroll_Text = true;
  while(true) {run_Scrolling_Text(4, 35, "Successfully connected to WiFi.", myGREEN);if (start_Scroll_Text == false) break;}
  delay(500);

  char IP_Add[30];
  sprintf(IP_Add, "IP Address : %s", WiFi.localIP().toString());
  start_Scroll_Text = true;
  while(true) {run_Scrolling_Text(4, 35, IP_Add, myWHITE);if (start_Scroll_Text == false) break;}
  delay(500);
}
//________________________________________________________________________________ 






//________________________________________________________________________________ VOID LOOP()
void loop() {
  // put your main code here, to run repeatedly:

  // Handle client requests.
  server.handleClient();




  //----------------------------------------input_Display_Mode = 1.
  if (input_Display_Mode == 1) {
    //::::::::::::::::::Timer/Millis to update clock data.
    unsigned long currentMillis_Update_Time = millis();
    if (currentMillis_Update_Time - prevMill_Update_Time >= interval_Update_Time) {
      prevMill_Update_Time = currentMillis_Update_Time;

      get_Time();
      blink_Colon = !blink_Colon;
    }
    //::::::::::::::::::

    //::::::::::::::::::Timer/Millis to display hours and minutes.
    unsigned long currentMillis_Show_Clock = millis();
    if (currentMillis_Show_Clock - prevMill_Show_Clock >= interval_Show_Clock) {
      prevMill_Show_Clock = currentMillis_Show_Clock;

      display.setTextSize(1);

      //clock_Color = myRED;

      if (last_minute_Val != minute_Val) display.fillRect(1, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(1, 0);
      display.print(chr_t_Hour);

      if (blink_Colon == true) {
        drawColon(15, 1, clock_Color);
      } else {
        drawColon(15, 1, myBLACK);
      }

      if (last_minute_Val != minute_Val) display.fillRect(20, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(20, 0);
      display.print(chr_t_Minute);

      last_minute_Val = minute_Val;
    }
    //::::::::::::::::::

    //::::::::::::::::::Conditions for setting and preparing scrolling text.
    // "start_Scroll_Text = false" means scrolling has not been executed.
    // After the settings and preparations for scrolling text below are complete, "start_Scroll_Text = true" to start scrolling text.
    // "start_Scroll_Text" will return "false" if scrolling the text is complete or the scrolled text is empty.
    if (start_Scroll_Text == false) {
      scrolling_text_Display_Order++;
      if (scrolling_text_Display_Order > 2) scrolling_text_Display_Order = 1;

      // Conditions for scrolling text containing the name of the day and date.
      if (scrolling_text_Display_Order == 1) {
        get_Date();
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        //input_Scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.
        //day_and_date_Text_Color = myGREEN;
        scrolling_Text_Color = day_and_date_Text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(text_Scrolling_Text, day_and_date_Text);  //--> Sets the displayed text on scrolling text.
      }

      // Conditions for scrolling the text you want.
      if (scrolling_text_Display_Order == 2) {
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        //input_Scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.
        //text_Color = myBLUE;
        scrolling_Text_Color = text_Color;  //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(text_Scrolling_Text, input_Scrolling_Text);  //--> Sets the displayed text on scrolling text.
      }

      start_Scroll_Text = true;
    }
    //::::::::::::::::::
  }
  //----------------------------------------
  



  //----------------------------------------input_Display_Mode = 2.
  if (input_Display_Mode == 2) {
    //::::::::::::::::::
    unsigned long currentMillis_Update_Time = millis();
    if (currentMillis_Update_Time - prevMill_Update_Time >= interval_Update_Time) {
      prevMill_Update_Time = currentMillis_Update_Time;

      get_Time();
      blink_Colon = !blink_Colon;
    }
    //::::::::::::::::::

    //::::::::::::::::::
    unsigned long currentMillis_Show_Clock = millis();
    if (currentMillis_Show_Clock - prevMill_Show_Clock >= interval_Show_Clock) {
      prevMill_Show_Clock = currentMillis_Show_Clock;

      display.setTextSize(1);

      clock_Color = myCOLOR_ARRAY[cnt_Color];

      if (last_minute_Val != minute_Val) display.fillRect(1, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(1, 0);
      display.print(chr_t_Hour);

      if (blink_Colon == true) {
        drawColon(15, 1, clock_Color);
      } else {
        drawColon(15, 1, myBLACK);
      }

      if (last_minute_Val != minute_Val) display.fillRect(20, 0, 11, 7, myBLACK);
      display.setTextColor(clock_Color);
      display.setCursor(20, 0);
      display.print(chr_t_Minute);

      last_minute_Val = minute_Val;
    }
    //::::::::::::::::::

    //::::::::::::::::::
    if (start_Scroll_Text == false) {
      scrolling_text_Display_Order++;
      if (scrolling_text_Display_Order > 3) scrolling_text_Display_Order = 1;

      if (scrolling_text_Display_Order == 1) {
        get_Date();
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        //input_Scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.

        int next_cnt_Color = cnt_Color + 1;
        if (next_cnt_Color > (myCOLOR_ARRAY_Length - 1)) next_cnt_Color = cnt_Color - (myCOLOR_ARRAY_Length - 1);
        day_and_date_Text_Color = myCOLOR_ARRAY[next_cnt_Color];
      
        scrolling_Text_Color = day_and_date_Text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);
        strcpy(text_Scrolling_Text, day_and_date_Text);  //--> Sets the displayed text on scrolling text.
      }

      if (scrolling_text_Display_Order == 2) {
        display.setTextSize(1);
        scrolling_Y_Pos = 8;  //--> Y position settings for scrolling text.
        //input_Scrolling_Speed = 45; //--> Speed ​​settings for scrolling text.

        int next_cnt_Color = cnt_Color + 2;
        if (next_cnt_Color > (myCOLOR_ARRAY_Length - 1)) next_cnt_Color = cnt_Color - (myCOLOR_ARRAY_Length - 2);
        text_Color = myCOLOR_ARRAY[next_cnt_Color];
        
        scrolling_Text_Color = text_Color; //--> Color settings for scrolling text. You can also use: scrolling_Text_Color = display.color565(255, 0, 0);      
        strcpy(text_Scrolling_Text, input_Scrolling_Text);  //--> Sets the displayed text on scrolling text.
      }

      // Conditions for changing color.
      if (scrolling_text_Display_Order == 3) {
        cnt_Color++;
        if (cnt_Color > (myCOLOR_ARRAY_Length - 1)) cnt_Color = 0;

        strcpy(text_Scrolling_Text, "");
      }

      start_Scroll_Text = true;
    }
    //::::::::::::::::::
  }
  //----------------------------------------
  


  
  if (start_Scroll_Text == true) {
    run_Scrolling_Text(scrolling_Y_Pos, input_Scrolling_Speed, text_Scrolling_Text, scrolling_Text_Color);
  }
}
//________________________________________________________________________________ 
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<






//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 06_P10_RGB_32x16_Digital_Clock_Web_Server_APM
//----------------------------------------Access Point Declaration and Configuration.
const char* ssid = "ESP32_WS";  //--> access point name
const char* password = "helloesp32WS"; //--> access point password

IPAddress local_ip(192,168,1,1);
IPAddress gateway(192,168,1,1);
IPAddress subnet(255,255,255,0);
//----------------------------------------

//________________________________________________________________________________ set_ESP32_Access_Point()
void set_ESP32_Access_Point() {
  //----------------------------------------Set Wifi to AP mode
  Serial.println();
  Serial.println("-------------");
  Serial.println("WIFI mode : AP");
  WiFi.mode(WIFI_AP);
  Serial.println("-------------");
  delay(1000);
  //---------------------------------------- 

  //----------------------------------------Setting up ESP32 to be an Access Point.
  Serial.println();
  Serial.println("-------------");
  Serial.println("Setting up ESP32 to be an Access Point.");
  WiFi.softAP(ssid, password); //--> Creating Access Points
  delay(1000);
  Serial.println("Setting up ESP32 softAPConfig.");
  WiFi.softAPConfig(local_ip, gateway, subnet);
  Serial.println("-------------");
  delay(1000);
  //----------------------------------------
}
//________________________________________________________________________________ 

//________________________________________________________________________________ prepare_and_start_The_Server()
void prepare_and_start_The_Server() {
  //----------------------------------------Setting the server.
  server.on("/", handleRoot); 
  server.on("/settings", handleSettings);
  delay(500);
  //----------------------------------------

  //----------------------------------------Start server.
  server.begin(); 
  Serial.println();
  Serial.println("HTTP server started");
  delay(500);
  //----------------------------------------

  //----------------------------------------Open the IP address in your browser to open the interface page.
  // Make sure your computer/mobile device is connected to the ESP32 Access Point.
  Serial.println();
  Serial.println();
  Serial.println("------------");
  Serial.print("SSID name : ");
  Serial.println(ssid);
  Serial.print("IP address : ");
  Serial.println(WiFi.softAPIP());
  Serial.println();
  Serial.println("Connect your computer or mobile Wifi to the SSID above.");
  Serial.println("Visit the IP Address above in your browser to open the main page.");
  Serial.println("------------");
  Serial.println();
  delay(500);
  //----------------------------------------
}
//________________________________________________________________________________ 

while(true) {run_Scrolling_Text(4, 35, "Set up the ESP32 Access Point.", myBLUE);if (start_Scroll_Text == false) break;}

while(true) {run_Scrolling_Text(4, 35, "Please Wait...", myRED);if (start_Scroll_Text == false) break;}

set_ESP32_Access_Point();

while(true) {run_Scrolling_Text(4, 35, "Set Up the ESP32 Access Point Successfully.", myGREEN);if (start_Scroll_Text == false) break;}

char IP_Add[30];
sprintf(IP_Add, "IP Address : %s", WiFi.softAPIP().toString());
start_Scroll_Text = true;
while(true) {run_Scrolling_Text(4, 35, IP_Add, myWHITE);if (start_Scroll_Text == false) break;}
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<